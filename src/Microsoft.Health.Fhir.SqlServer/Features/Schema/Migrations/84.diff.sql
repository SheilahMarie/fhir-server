SET TRANSACTION ISOLATION LEVEL READ COMMITTED -- Not sure that it matters, but to gurantee that SQL versioning is not used-- Disable defragUPDATE Parameters SET Number = 0 WHERE Id = 'DefragWatchdog.IsEnabled'EXECUTE dbo.LogEvent @Process='HistorySeparation',@Status='Warn',@Target='Parameters',@Action='Update',@Rows=@@rowcount,@Text='disable defrag'GOIF (SELECT sum(reserved_page_count*8.0/1024/1024) FROM sys.dm_db_partition_stats) > 2500 -- skip for large databasesBEGIN  INSERT INTO dbo.Parameters (Id, Number) SELECT 'SkipHistorySeparation', 1  EXECUTE dbo.LogEvent @Process='HistorySeparation',@Status='Warn',@Target='Parameters',@Action='Insert',@Rows=@@rowcount,@Text='SkipHistorySeparation'ENDGOALTER PROCEDURE dbo.GetResourcesByTypeAndSurrogateIdRange @ResourceTypeId smallint, @StartId bigint, @EndId bigint, @GlobalStartId bigint = NULL, @GlobalEndId bigint = NULLASset nocount onDECLARE @SP varchar(100) = 'GetResourcesByTypeAndSurrogateIdRange'       ,@Mode varchar(100) = 'RT='+isnull(convert(varchar,@ResourceTypeId),'NULL')                           +' S='+isnull(convert(varchar,@StartId),'NULL')                           +' E='+isnull(convert(varchar,@EndId),'NULL')                           +' GE='+isnull(convert(varchar,@GlobalEndId),'NULL') -- Could this just be a boolean for if historical records should be returned? GlobalEndId should equal EndId in all cases I can think of.       ,@st datetime = getUTCdate()       ,@DummyTop bigint = 9223372036854775807BEGIN TRY  DECLARE @ResourceIds TABLE (ResourceId varchar(64) COLLATE Latin1_General_100_CS_AS PRIMARY KEY)  DECLARE @SurrogateIds TABLE (MaxSurrogateId bigint PRIMARY KEY)  IF @GlobalEndId IS NOT NULL -- snapshot view  BEGIN    INSERT INTO @ResourceIds      SELECT DISTINCT ResourceId        FROM dbo.Resource         WHERE ResourceTypeId = @ResourceTypeId           AND ResourceSurrogateId BETWEEN @StartId AND @EndId          AND IsHistory = 1          AND IsDeleted = 0        OPTION (MAXDOP 1)    IF @@rowcount > 0      INSERT INTO @SurrogateIds        SELECT ResourceSurrogateId          FROM (SELECT ResourceId, ResourceSurrogateId, RowId = row_number() OVER (PARTITION BY ResourceId ORDER BY ResourceSurrogateId DESC)                  FROM dbo.Resource WITH (INDEX = IX_Resource_ResourceTypeId_ResourceId_Version) -- w/o hint access to Resource table is inefficient when many versions are present. Hint is ignored if Resource is a view.                  WHERE ResourceTypeId = @ResourceTypeId                    AND ResourceId IN (SELECT TOP (@DummyTop) ResourceId FROM @ResourceIds)                    AND ResourceSurrogateId BETWEEN @StartId AND @GlobalEndId               ) A          WHERE RowId = 1            AND ResourceSurrogateId BETWEEN @StartId AND @EndId          OPTION (MAXDOP 1, OPTIMIZE FOR (@DummyTop = 1))  END  SELECT ResourceTypeId, ResourceId, Version, IsDeleted, ResourceSurrogateId, RequestMethod, IsMatch = convert(bit,1), IsPartial = convert(bit,0), IsRawResourceMetaSet, SearchParamHash, RawResource     FROM dbo.Resource    WHERE ResourceTypeId = @ResourceTypeId       AND ResourceSurrogateId BETWEEN @StartId AND @EndId       AND IsHistory = 0      AND IsDeleted = 0  UNION ALL  SELECT ResourceTypeId, ResourceId, Version, IsDeleted, ResourceSurrogateId, RequestMethod, IsMatch = convert(bit,1), IsPartial = convert(bit,0), IsRawResourceMetaSet, SearchParamHash, RawResource     FROM @SurrogateIds         JOIN dbo.Resource ON ResourceTypeId = @ResourceTypeId AND ResourceSurrogateId = MaxSurrogateId    WHERE IsHistory = 1      AND IsDeleted = 0      OPTION (MAXDOP 1)  EXECUTE dbo.LogEvent @Process=@SP,@Mode=@Mode,@Status='End',@Start=@st,@Rows=@@rowcountEND TRYBEGIN CATCH  IF error_number() = 1750 THROW -- Real error is before 1750, cannot trap in SQL.  EXECUTE dbo.LogEvent @Process=@SP,@Mode=@Mode,@Status='Error';  THROWEND CATCHGOALTER PROCEDURE dbo.DequeueJob @QueueType tinyint, @Worker varchar(100), @HeartbeatTimeoutSec int, @InputJobId bigint = NULL, @CheckTimeoutJobs bit = 0ASset nocount onDECLARE @SP varchar(100) = 'DequeueJob'       ,@Mode varchar(100) = 'Q='+isnull(convert(varchar,@QueueType),'NULL')                           +' H='+isnull(convert(varchar,@HeartbeatTimeoutSec),'NULL')                           +' W='+isnull(@Worker,'NULL')                           +' IJ='+isnull(convert(varchar,@InputJobId),'NULL')                           +' T='+isnull(convert(varchar,@CheckTimeoutJobs),'NULL')       ,@Rows int = 0       ,@st datetime = getUTCdate()       ,@JobId bigint       ,@msg varchar(100)       ,@Lock varchar(100)       ,@PartitionId tinyint       ,@MaxPartitions tinyint = 16 -- !!! hardcoded       ,@LookedAtPartitions tinyint = 0BEGIN TRY  IF EXISTS (SELECT * FROM dbo.Parameters WHERE Id = 'DequeueJobStop' AND Number = 1)  BEGIN    EXECUTE dbo.LogEvent @Process=@SP,@Mode=@Mode,@Status='End',@Start=@st,@Rows=0,@Text='Skipped'    RETURN  END  IF @InputJobId IS NULL    SET @PartitionId = @MaxPartitions * rand()  ELSE     SET @PartitionId = @InputJobId % 16  SET TRANSACTION ISOLATION LEVEL READ COMMITTED   WHILE @InputJobId IS NULL AND @JobId IS NULL AND @LookedAtPartitions < @MaxPartitions AND @CheckTimeoutJobs = 0  BEGIN    SET @Lock = 'DequeueJob_'+convert(varchar,@QueueType)+'_'+convert(varchar,@PartitionId)    BEGIN TRANSACTION      EXECUTE sp_getapplock @Lock, 'Exclusive'    UPDATE T      SET StartDate = getUTCdate()         ,HeartbeatDate = getUTCdate()         ,Worker = @Worker          ,Status = 1 -- running         ,Version = datediff_big(millisecond,'0001-01-01',getUTCdate())         ,@JobId = T.JobId      FROM dbo.JobQueue T WITH (PAGLOCK)           JOIN (SELECT TOP 1                         JobId                   FROM dbo.JobQueue WITH (INDEX = IX_QueueType_PartitionId_Status_Priority)                   WHERE QueueType = @QueueType                     AND PartitionId = @PartitionId                     AND Status = 0                   ORDER BY                         Priority                       ,JobId                ) S             ON QueueType = @QueueType AND PartitionId = @PartitionId AND T.JobId = S.JobId    SET @Rows += @@rowcount    COMMIT TRANSACTION    IF @JobId IS NULL    BEGIN      SET @PartitionId = CASE WHEN @PartitionId = 15 THEN 0 ELSE @PartitionId + 1 END      SET @LookedAtPartitions = @LookedAtPartitions + 1     END  END  -- Do timed out items.   SET @LookedAtPartitions = 0  WHILE @InputJobId IS NULL AND @JobId IS NULL AND @LookedAtPartitions < @MaxPartitions  BEGIN    SET @Lock = 'DequeueStoreCopyWorkUnit_'+convert(varchar, @PartitionId)    BEGIN TRANSACTION      EXECUTE sp_getapplock @Lock, 'Exclusive'    UPDATE T      SET StartDate = getUTCdate()         ,HeartbeatDate = getUTCdate()         ,Worker = @Worker          ,Status = CASE WHEN CancelRequested = 0 THEN 1 ELSE 4 END          ,Version = datediff_big(millisecond,'0001-01-01',getUTCdate())         ,@JobId = CASE WHEN CancelRequested = 0 THEN T.JobId END         ,Info = convert(varchar(1000),isnull(Info,'')+' Prev: Worker='+Worker+' Start='+convert(varchar,StartDate,121))      FROM dbo.JobQueue T WITH (PAGLOCK)           JOIN (SELECT TOP 1                         JobId                   FROM dbo.JobQueue WITH (INDEX = IX_QueueType_PartitionId_Status_Priority)                   WHERE QueueType = @QueueType                     AND PartitionId = @PartitionId                     AND Status = 1                     AND datediff(second,HeartbeatDate,getUTCdate()) > @HeartbeatTimeoutSec                   ORDER BY                         Priority                       ,JobId                ) S             ON QueueType = @QueueType AND PartitionId = @PartitionId AND T.JobId = S.JobId    SET @Rows += @@rowcount    COMMIT TRANSACTION    IF @JobId IS NULL    BEGIN      SET @PartitionId = CASE WHEN @PartitionId = 15 THEN 0 ELSE @PartitionId + 1 END      SET @LookedAtPartitions = @LookedAtPartitions + 1     END  END  IF @InputJobId IS NOT NULL  BEGIN    UPDATE dbo.JobQueue WITH (PAGLOCK)      SET StartDate = getUTCdate()         ,HeartbeatDate = getUTCdate()         ,Worker = @Worker          ,Status = 1 -- running         ,Version = datediff_big(millisecond,'0001-01-01',getUTCdate())         ,@JobId = JobId      WHERE QueueType = @QueueType AND PartitionId = @PartitionId AND Status = 0 AND JobId = @InputJobId     SET @Rows += @@rowcount    IF @JobId IS NULL    BEGIN      UPDATE dbo.JobQueue WITH (PAGLOCK)        SET StartDate = getUTCdate()           ,HeartbeatDate = getUTCdate()           ,Worker = @Worker            ,Status = 1 -- running           ,Version = datediff_big(millisecond,'0001-01-01',getUTCdate())           ,@JobId = JobId        WHERE QueueType = @QueueType AND PartitionId = @PartitionId AND Status = 1 AND JobId = @InputJobId          AND datediff(second,HeartbeatDate,getUTCdate()) > @HeartbeatTimeoutSec      SET @Rows += @@rowcount    END  END  IF @JobId IS NOT NULL    EXECUTE dbo.GetJobs @QueueType = @QueueType, @JobId = @JobId    SET @msg = 'J='+isnull(convert(varchar,@JobId),'NULL')+' P='+convert(varchar,@PartitionId)  EXECUTE dbo.LogEvent @Process=@SP,@Mode=@Mode,@Status='End',@Start=@st,@Rows=@Rows,@Text=@msgEND TRYBEGIN CATCH  IF @@trancount > 0 ROLLBACK TRANSACTION  IF error_number() = 1750 THROW -- Real error is before 1750, cannot trap in SQL.  EXECUTE dbo.LogEvent @Process=@SP,@Mode=@Mode,@Status='Error';  THROWEND CATCHGOEXECUTE dbo.LogEvent @Process='65.diff.sql',@Status='Warn',@Target='DequeueJob',@Action='Alter'GOALTER PROCEDURE dbo.GetActiveJobs @QueueType tinyint, @GroupId bigint = NULLASset nocount onDECLARE @SP varchar(100) = 'GetActiveJobs'       ,@Mode varchar(100) = 'Q='+isnull(convert(varchar,@QueueType),'NULL')                           +' G='+isnull(convert(varchar,@GroupId),'NULL')       ,@st datetime = getUTCdate()       ,@JobIds BigintList       ,@PartitionId tinyint       ,@MaxPartitions tinyint = 16 -- !!! hardcoded       ,@LookedAtPartitions tinyint = 0       ,@Rows int = 0BEGIN TRY  SET @PartitionId = @MaxPartitions * rand()  WHILE @LookedAtPartitions < @MaxPartitions  BEGIN    IF @GroupId IS NULL      INSERT INTO @JobIds SELECT JobId FROM dbo.JobQueue WHERE PartitionId = @PartitionId AND QueueType = @QueueType AND Status IN (0,1)    ELSE      INSERT INTO @JobIds SELECT JobId FROM dbo.JobQueue WHERE PartitionId = @PartitionId AND QueueType = @QueueType AND GroupId = @GroupId AND Status IN (0,1)    SET @Rows += @@rowcount    SET @PartitionId = CASE WHEN @PartitionId = 15 THEN 0 ELSE @PartitionId + 1 END    SET @LookedAtPartitions += 1   END  IF @Rows > 0    EXECUTE dbo.GetJobs @QueueType = @QueueType, @JobIds = @JobIds  EXECUTE dbo.LogEvent @Process=@SP,@Mode=@Mode,@Status='End',@Start=@st,@Rows=@RowsEND TRYBEGIN CATCH  IF error_number() = 1750 THROW -- Real error is before 1750, cannot trap in SQL.  EXECUTE dbo.LogEvent @Process=@SP,@Mode=@Mode,@Status='Error';  THROWEND CATCHGOEXECUTE dbo.LogEvent @Process='65.diff.sql',@Status='Warn',@Target='GetActiveJobs',@Action='Alter'GOINSERT INTO dbo.Parameters (Id, Char) SELECT 'HistorySeparation', 'LogEvent'EXECUTE dbo.LogEvent @Process='HistorySeparation',@Status='Start'GOALTER PROCEDURE dbo.GetResources @ResourceKeys dbo.ResourceKeyList READONLYASset nocount onDECLARE @st datetime = getUTCdate()       ,@SP varchar(100) = 'GetResources'       ,@InputRows int       ,@DummyTop bigint = 9223372036854775807       ,@NotNullVersionExists bit        ,@NullVersionExists bit       ,@MinRT smallint       ,@MaxRT smallintSELECT @MinRT = min(ResourceTypeId), @MaxRT = max(ResourceTypeId), @InputRows = count(*), @NotNullVersionExists = max(CASE WHEN Version IS NOT NULL THEN 1 ELSE 0 END), @NullVersionExists = max(CASE WHEN Version IS NULL THEN 1 ELSE 0 END) FROM @ResourceKeysDECLARE @Mode varchar(100) = 'RT=['+convert(varchar,@MinRT)+','+convert(varchar,@MaxRT)+'] Cnt='+convert(varchar,@InputRows)+' NNVE='+convert(varchar,@NotNullVersionExists)+' NVE='+convert(varchar,@NullVersionExists)BEGIN TRY  IF @NotNullVersionExists = 1    IF @NullVersionExists = 0      SELECT B.ResourceTypeId            ,B.ResourceId            ,ResourceSurrogateId            ,B.Version            ,IsDeleted            ,IsHistory            ,RawResource            ,IsRawResourceMetaSet            ,SearchParamHash        FROM (SELECT TOP (@DummyTop) * FROM @ResourceKeys) A             JOIN dbo.Resource B ON B.ResourceTypeId = A.ResourceTypeId AND B.ResourceId = A.ResourceId AND B.Version = A.Version        OPTION (MAXDOP 1, OPTIMIZE FOR (@DummyTop = 1))    ELSE      SELECT *        FROM (SELECT B.ResourceTypeId                    ,B.ResourceId                    ,ResourceSurrogateId                    ,B.Version                    ,IsDeleted                    ,IsHistory                    ,RawResource                    ,IsRawResourceMetaSet                    ,SearchParamHash                FROM (SELECT TOP (@DummyTop) * FROM @ResourceKeys WHERE Version IS NOT NULL) A                     JOIN dbo.Resource B ON B.ResourceTypeId = A.ResourceTypeId AND B.ResourceId = A.ResourceId AND B.Version = A.Version              UNION ALL              SELECT B.ResourceTypeId                    ,B.ResourceId                    ,ResourceSurrogateId                    ,B.Version                    ,IsDeleted                    ,IsHistory                    ,RawResource                    ,IsRawResourceMetaSet                    ,SearchParamHash                FROM (SELECT TOP (@DummyTop) * FROM @ResourceKeys WHERE Version IS NULL) A                     JOIN dbo.Resource B ON B.ResourceTypeId = A.ResourceTypeId AND B.ResourceId = A.ResourceId                WHERE IsHistory = 0             ) A        OPTION (MAXDOP 1, OPTIMIZE FOR (@DummyTop = 1))  ELSE    SELECT B.ResourceTypeId          ,B.ResourceId          ,ResourceSurrogateId          ,B.Version          ,IsDeleted          ,IsHistory          ,RawResource          ,IsRawResourceMetaSet          ,SearchParamHash      FROM (SELECT TOP (@DummyTop) * FROM @ResourceKeys) A           JOIN dbo.Resource B ON B.ResourceTypeId = A.ResourceTypeId AND B.ResourceId = A.ResourceId      WHERE IsHistory = 0      OPTION (MAXDOP 1, OPTIMIZE FOR (@DummyTop = 1))  EXECUTE dbo.LogEvent @Process=@SP,@Mode=@Mode,@Status='End',@Start=@st,@Rows=@@rowcountEND TRYBEGIN CATCH  IF error_number() = 1750 THROW -- Real error is before 1750, cannot trap in SQL.  EXECUTE dbo.LogEvent @Process=@SP,@Mode=@Mode,@Status='Error',@Start=@st;  THROWEND CATCHGOEXECUTE dbo.LogEvent @Process='HistorySeparation',@Status='Run',@Target='GetResources',@Action='Alter'GOALTER PROCEDURE dbo.MergeResources-- This stored procedure can be used for:-- 1. Ordinary put with single version per resource in input-- 2. Put with history preservation (multiple input versions per resource)-- 3. Copy from one gen2 store to another with ResourceSurrogateId preserved.    @AffectedRows int = 0 OUT   ,@RaiseExceptionOnConflict bit = 1   ,@IsResourceChangeCaptureEnabled bit = 0   ,@TransactionId bigint = NULL   ,@SingleTransaction bit = 1   ,@Resources dbo.ResourceList READONLY   ,@ResourceWriteClaims dbo.ResourceWriteClaimList READONLY   ,@ReferenceSearchParams dbo.ReferenceSearchParamList READONLY   ,@TokenSearchParams dbo.TokenSearchParamList READONLY   ,@TokenTexts dbo.TokenTextList READONLY   ,@StringSearchParams dbo.StringSearchParamList READONLY   ,@UriSearchParams dbo.UriSearchParamList READONLY   ,@NumberSearchParams dbo.NumberSearchParamList READONLY   ,@QuantitySearchParams dbo.QuantitySearchParamList READONLY   ,@DateTimeSearchParms dbo.DateTimeSearchParamList READONLY   ,@ReferenceTokenCompositeSearchParams dbo.ReferenceTokenCompositeSearchParamList READONLY   ,@TokenTokenCompositeSearchParams dbo.TokenTokenCompositeSearchParamList READONLY   ,@TokenDateTimeCompositeSearchParams dbo.TokenDateTimeCompositeSearchParamList READONLY   ,@TokenQuantityCompositeSearchParams dbo.TokenQuantityCompositeSearchParamList READONLY   ,@TokenStringCompositeSearchParams dbo.TokenStringCompositeSearchParamList READONLY   ,@TokenNumberNumberCompositeSearchParams dbo.TokenNumberNumberCompositeSearchParamList READONLYASset nocount onDECLARE @st datetime = getUTCdate()       ,@SP varchar(100) = object_name(@@procid)       ,@DummyTop bigint = 9223372036854775807       ,@InitialTranCount int = @@trancount       ,@IsRetry bit = 0DECLARE @Mode varchar(200) = isnull((SELECT 'RT=['+convert(varchar,min(ResourceTypeId))+','+convert(varchar,max(ResourceTypeId))+'] Sur=['+convert(varchar,min(ResourceSurrogateId))+','+convert(varchar,max(ResourceSurrogateId))+'] V='+convert(varchar,max(Version))+' Rows='+convert(varchar,count(*)) FROM @Resources),'Input=Empty')SET @Mode += ' E='+convert(varchar,@RaiseExceptionOnConflict)+' CC='+convert(varchar,@IsResourceChangeCaptureEnabled)+' IT='+convert(varchar,@InitialTranCount)+' T='+isnull(convert(varchar,@TransactionId),'NULL')SET @AffectedRows = 0BEGIN TRY  DECLARE @Existing AS TABLE (ResourceTypeId smallint NOT NULL, SurrogateId bigint NOT NULL PRIMARY KEY (ResourceTypeId, SurrogateId))  DECLARE @ResourceInfos AS TABLE    (       ResourceTypeId       smallint       NOT NULL      ,SurrogateId          bigint         NOT NULL      ,Version              int            NOT NULL      ,KeepHistory          bit            NOT NULL      ,PreviousVersion      int            NULL      ,PreviousSurrogateId  bigint         NULL      PRIMARY KEY (ResourceTypeId, SurrogateId)    )  DECLARE @PreviousSurrogateIds AS TABLE (TypeId smallint NOT NULL, SurrogateId bigint NOT NULL PRIMARY KEY (TypeId, SurrogateId), KeepHistory bit)  IF @SingleTransaction = 0 AND isnull((SELECT Number FROM dbo.Parameters WHERE Id = 'MergeResources.NoTransaction.IsEnabled'),0) = 0    SET @SingleTransaction = 1    SET @Mode += ' ST='+convert(varchar,@SingleTransaction)  -- perform retry check in transaction to hold locks  IF @InitialTranCount = 0  BEGIN    IF EXISTS (SELECT * -- This extra statement avoids putting range locks when we don't need them                 FROM @Resources A JOIN dbo.Resource B ON B.ResourceTypeId = A.ResourceTypeId AND B.ResourceSurrogateId = A.ResourceSurrogateId                 WHERE B.IsHistory = 0              )    BEGIN      BEGIN TRANSACTION      INSERT INTO @Existing              (  ResourceTypeId,           SurrogateId )        SELECT B.ResourceTypeId, B.ResourceSurrogateId          FROM (SELECT TOP (@DummyTop) * FROM @Resources) A               JOIN dbo.Resource B WITH (ROWLOCK, HOLDLOCK) ON B.ResourceTypeId = A.ResourceTypeId AND B.ResourceSurrogateId = A.ResourceSurrogateId          WHERE B.IsHistory = 0          OPTION (MAXDOP 1, OPTIMIZE FOR (@DummyTop = 1))          IF @@rowcount > 0 SET @IsRetry = 1      IF @IsRetry = 0 COMMIT TRANSACTION -- commit check transaction     END  END  SET @Mode += ' R='+convert(varchar,@IsRetry)  IF @SingleTransaction = 1 AND @@trancount = 0 BEGIN TRANSACTION    IF @IsRetry = 0  BEGIN    INSERT INTO @ResourceInfos            (  ResourceTypeId,           SurrogateId,   Version,   KeepHistory, PreviousVersion,   PreviousSurrogateId )      SELECT A.ResourceTypeId, A.ResourceSurrogateId, A.Version, A.KeepHistory,       B.Version, B.ResourceSurrogateId        FROM (SELECT TOP (@DummyTop) * FROM @Resources WHERE HasVersionToCompare = 1) A             LEFT OUTER JOIN dbo.Resource B -- WITH (UPDLOCK, HOLDLOCK) These locking hints cause deadlocks and are not needed. Racing might lead to tries to insert dups in unique index (with version key), but it will fail anyway, and in no case this will cause incorrect data saved.               ON B.ResourceTypeId = A.ResourceTypeId AND B.ResourceId = A.ResourceId AND B.IsHistory = 0        OPTION (MAXDOP 1, OPTIMIZE FOR (@DummyTop = 1))    IF @RaiseExceptionOnConflict = 1 AND EXISTS (SELECT * FROM @ResourceInfos WHERE PreviousVersion IS NOT NULL AND Version <> PreviousVersion + 1)      THROW 50409, 'Resource has been recently updated or added, please compare the resource content in code for any duplicate updates', 1    INSERT INTO @PreviousSurrogateIds      SELECT ResourceTypeId, PreviousSurrogateId, KeepHistory        FROM @ResourceInfos         WHERE PreviousSurrogateId IS NOT NULL    IF @@rowcount > 0    BEGIN      UPDATE dbo.Resource        SET IsHistory = 1        WHERE EXISTS (SELECT * FROM @PreviousSurrogateIds WHERE TypeId = ResourceTypeId AND SurrogateId = ResourceSurrogateId AND KeepHistory = 1)      SET @AffectedRows += @@rowcount      IF @IsResourceChangeCaptureEnabled = 1 AND NOT EXISTS (SELECT * FROM dbo.Parameters WHERE Id = 'InvisibleHistory.IsEnabled' AND Number = 0)        UPDATE dbo.Resource          SET IsHistory = 1             ,RawResource = 0xF -- "invisible" value             ,SearchParamHash = NULL             ,HistoryTransactionId = @TransactionId          WHERE EXISTS (SELECT * FROM @PreviousSurrogateIds WHERE TypeId = ResourceTypeId AND SurrogateId = ResourceSurrogateId AND KeepHistory = 0)      ELSE        DELETE FROM dbo.Resource WHERE EXISTS (SELECT * FROM @PreviousSurrogateIds WHERE TypeId = ResourceTypeId AND SurrogateId = ResourceSurrogateId AND KeepHistory = 0)      SET @AffectedRows += @@rowcount      DELETE FROM dbo.ResourceWriteClaim WHERE EXISTS (SELECT * FROM @PreviousSurrogateIds WHERE SurrogateId = ResourceSurrogateId)      SET @AffectedRows += @@rowcount      DELETE FROM dbo.ReferenceSearchParam WHERE EXISTS (SELECT * FROM @PreviousSurrogateIds WHERE TypeId = ResourceTypeId AND SurrogateId = ResourceSurrogateId)      SET @AffectedRows += @@rowcount      DELETE FROM dbo.TokenSearchParam WHERE EXISTS (SELECT * FROM @PreviousSurrogateIds WHERE TypeId = ResourceTypeId AND SurrogateId = ResourceSurrogateId)      SET @AffectedRows += @@rowcount      DELETE FROM dbo.TokenText WHERE EXISTS (SELECT * FROM @PreviousSurrogateIds WHERE TypeId = ResourceTypeId AND SurrogateId = ResourceSurrogateId)      SET @AffectedRows += @@rowcount      DELETE FROM dbo.StringSearchParam WHERE EXISTS (SELECT * FROM @PreviousSurrogateIds WHERE TypeId = ResourceTypeId AND SurrogateId = ResourceSurrogateId)      SET @AffectedRows += @@rowcount      DELETE FROM dbo.UriSearchParam WHERE EXISTS (SELECT * FROM @PreviousSurrogateIds WHERE TypeId = ResourceTypeId AND SurrogateId = ResourceSurrogateId)      SET @AffectedRows += @@rowcount      DELETE FROM dbo.NumberSearchParam WHERE EXISTS (SELECT * FROM @PreviousSurrogateIds WHERE TypeId = ResourceTypeId AND SurrogateId = ResourceSurrogateId)      SET @AffectedRows += @@rowcount      DELETE FROM dbo.QuantitySearchParam WHERE EXISTS (SELECT * FROM @PreviousSurrogateIds WHERE TypeId = ResourceTypeId AND SurrogateId = ResourceSurrogateId)      SET @AffectedRows += @@rowcount      DELETE FROM dbo.DateTimeSearchParam WHERE EXISTS (SELECT * FROM @PreviousSurrogateIds WHERE TypeId = ResourceTypeId AND SurrogateId = ResourceSurrogateId)      SET @AffectedRows += @@rowcount      DELETE FROM dbo.ReferenceTokenCompositeSearchParam WHERE EXISTS (SELECT * FROM @PreviousSurrogateIds WHERE TypeId = ResourceTypeId AND SurrogateId = ResourceSurrogateId)      SET @AffectedRows += @@rowcount      DELETE FROM dbo.TokenTokenCompositeSearchParam WHERE EXISTS (SELECT * FROM @PreviousSurrogateIds WHERE TypeId = ResourceTypeId AND SurrogateId = ResourceSurrogateId)      SET @AffectedRows += @@rowcount      DELETE FROM dbo.TokenDateTimeCompositeSearchParam WHERE EXISTS (SELECT * FROM @PreviousSurrogateIds WHERE TypeId = ResourceTypeId AND SurrogateId = ResourceSurrogateId)      SET @AffectedRows += @@rowcount      DELETE FROM dbo.TokenQuantityCompositeSearchParam WHERE EXISTS (SELECT * FROM @PreviousSurrogateIds WHERE TypeId = ResourceTypeId AND SurrogateId = ResourceSurrogateId)      SET @AffectedRows += @@rowcount      DELETE FROM dbo.TokenStringCompositeSearchParam WHERE EXISTS (SELECT * FROM @PreviousSurrogateIds WHERE TypeId = ResourceTypeId AND SurrogateId = ResourceSurrogateId)      SET @AffectedRows += @@rowcount      DELETE FROM dbo.TokenNumberNumberCompositeSearchParam WHERE EXISTS (SELECT * FROM @PreviousSurrogateIds WHERE TypeId = ResourceTypeId AND SurrogateId = ResourceSurrogateId)      SET @AffectedRows += @@rowcount      --EXECUTE dbo.LogEvent @Process=@SP,@Mode=@Mode,@Status='Info',@Start=@st,@Rows=@AffectedRows,@Text='Old rows'    END    INSERT INTO dbo.Resource            ( ResourceTypeId, ResourceId, Version, IsHistory, ResourceSurrogateId, IsDeleted, RequestMethod, RawResource, IsRawResourceMetaSet, SearchParamHash,  TransactionId )      SELECT ResourceTypeId, ResourceId, Version, IsHistory, ResourceSurrogateId, IsDeleted, RequestMethod, RawResource, IsRawResourceMetaSet, SearchParamHash, @TransactionId        FROM @Resources    SET @AffectedRows += @@rowcount    INSERT INTO dbo.ResourceWriteClaim            ( ResourceSurrogateId, ClaimTypeId, ClaimValue )      SELECT ResourceSurrogateId, ClaimTypeId, ClaimValue        FROM @ResourceWriteClaims    SET @AffectedRows += @@rowcount    INSERT INTO dbo.ReferenceSearchParam            ( ResourceTypeId, ResourceSurrogateId, SearchParamId, BaseUri, ReferenceResourceTypeId, ReferenceResourceId, ReferenceResourceVersion )      SELECT ResourceTypeId, ResourceSurrogateId, SearchParamId, BaseUri, ReferenceResourceTypeId, ReferenceResourceId, ReferenceResourceVersion        FROM @ReferenceSearchParams    SET @AffectedRows += @@rowcount    INSERT INTO dbo.TokenSearchParam            ( ResourceTypeId, ResourceSurrogateId, SearchParamId, SystemId, Code, CodeOverflow )      SELECT ResourceTypeId, ResourceSurrogateId, SearchParamId, SystemId, Code, CodeOverflow        FROM @TokenSearchParams    SET @AffectedRows += @@rowcount    INSERT INTO dbo.TokenText            ( ResourceTypeId, ResourceSurrogateId, SearchParamId, Text )      SELECT ResourceTypeId, ResourceSurrogateId, SearchParamId, Text        FROM @TokenTexts    SET @AffectedRows += @@rowcount    INSERT INTO dbo.StringSearchParam            ( ResourceTypeId, ResourceSurrogateId, SearchParamId, Text, TextOverflow, IsMin, IsMax )      SELECT ResourceTypeId, ResourceSurrogateId, SearchParamId, Text, TextOverflow, IsMin, IsMax        FROM @StringSearchParams    SET @AffectedRows += @@rowcount    INSERT INTO dbo.UriSearchParam            ( ResourceTypeId, ResourceSurrogateId, SearchParamId, Uri )      SELECT ResourceTypeId, ResourceSurrogateId, SearchParamId, Uri        FROM @UriSearchParams    SET @AffectedRows += @@rowcount    INSERT INTO dbo.NumberSearchParam            ( ResourceTypeId, ResourceSurrogateId, SearchParamId, SingleValue, LowValue, HighValue )      SELECT ResourceTypeId, ResourceSurrogateId, SearchParamId, SingleValue, LowValue, HighValue        FROM @NumberSearchParams    SET @AffectedRows += @@rowcount    INSERT INTO dbo.QuantitySearchParam            ( ResourceTypeId, ResourceSurrogateId, SearchParamId, SystemId, QuantityCodeId, SingleValue, LowValue, HighValue )      SELECT ResourceTypeId, ResourceSurrogateId, SearchParamId, SystemId, QuantityCodeId, SingleValue, LowValue, HighValue        FROM @QuantitySearchParams    SET @AffectedRows += @@rowcount    INSERT INTO dbo.DateTimeSearchParam            ( ResourceTypeId, ResourceSurrogateId, SearchParamId, StartDateTime, EndDateTime, IsLongerThanADay, IsMin, IsMax )      SELECT ResourceTypeId, ResourceSurrogateId, SearchParamId, StartDateTime, EndDateTime, IsLongerThanADay, IsMin, IsMax        FROM @DateTimeSearchParms    SET @AffectedRows += @@rowcount    INSERT INTO dbo.ReferenceTokenCompositeSearchParam            ( ResourceTypeId, ResourceSurrogateId, SearchParamId, BaseUri1, ReferenceResourceTypeId1, ReferenceResourceId1, ReferenceResourceVersion1, SystemId2, Code2, CodeOverflow2 )      SELECT ResourceTypeId, ResourceSurrogateId, SearchParamId, BaseUri1, ReferenceResourceTypeId1, ReferenceResourceId1, ReferenceResourceVersion1, SystemId2, Code2, CodeOverflow2        FROM @ReferenceTokenCompositeSearchParams    SET @AffectedRows += @@rowcount    INSERT INTO dbo.TokenTokenCompositeSearchParam            ( ResourceTypeId, ResourceSurrogateId, SearchParamId, SystemId1, Code1, CodeOverflow1, SystemId2, Code2, CodeOverflow2 )      SELECT ResourceTypeId, ResourceSurrogateId, SearchParamId, SystemId1, Code1, CodeOverflow1, SystemId2, Code2, CodeOverflow2        FROM @TokenTokenCompositeSearchParams    SET @AffectedRows += @@rowcount    INSERT INTO dbo.TokenDateTimeCompositeSearchParam            ( ResourceTypeId, ResourceSurrogateId, SearchParamId, SystemId1, Code1, CodeOverflow1, StartDateTime2, EndDateTime2, IsLongerThanADay2 )      SELECT ResourceTypeId, ResourceSurrogateId, SearchParamId, SystemId1, Code1, CodeOverflow1, StartDateTime2, EndDateTime2, IsLongerThanADay2        FROM @TokenDateTimeCompositeSearchParams    SET @AffectedRows += @@rowcount    INSERT INTO dbo.TokenQuantityCompositeSearchParam            ( ResourceTypeId, ResourceSurrogateId, SearchParamId, SystemId1, Code1, CodeOverflow1, SingleValue2, SystemId2, QuantityCodeId2, LowValue2, HighValue2 )      SELECT ResourceTypeId, ResourceSurrogateId, SearchParamId, SystemId1, Code1, CodeOverflow1, SingleValue2, SystemId2, QuantityCodeId2, LowValue2, HighValue2        FROM @TokenQuantityCompositeSearchParams    SET @AffectedRows += @@rowcount    INSERT INTO dbo.TokenStringCompositeSearchParam            ( ResourceTypeId, ResourceSurrogateId, SearchParamId, SystemId1, Code1, CodeOverflow1, Text2, TextOverflow2 )      SELECT ResourceTypeId, ResourceSurrogateId, SearchParamId, SystemId1, Code1, CodeOverflow1, Text2, TextOverflow2        FROM @TokenStringCompositeSearchParams    SET @AffectedRows += @@rowcount    INSERT INTO dbo.TokenNumberNumberCompositeSearchParam            ( ResourceTypeId, ResourceSurrogateId, SearchParamId, SystemId1, Code1, CodeOverflow1, SingleValue2, LowValue2, HighValue2, SingleValue3, LowValue3, HighValue3, HasRange )      SELECT ResourceTypeId, ResourceSurrogateId, SearchParamId, SystemId1, Code1, CodeOverflow1, SingleValue2, LowValue2, HighValue2, SingleValue3, LowValue3, HighValue3, HasRange        FROM @TokenNumberNumberCompositeSearchParams    SET @AffectedRows += @@rowcount  END -- @IsRetry = 0  ELSE  BEGIN -- @IsRetry = 1    INSERT INTO dbo.ResourceWriteClaim            ( ResourceSurrogateId, ClaimTypeId, ClaimValue )      SELECT ResourceSurrogateId, ClaimTypeId, ClaimValue        FROM (SELECT TOP (@DummyTop) * FROM @ResourceWriteClaims) A        WHERE EXISTS (SELECT * FROM @Existing B WHERE B.SurrogateId = A.ResourceSurrogateId)          AND NOT EXISTS (SELECT * FROM dbo.ResourceWriteClaim C WHERE C.ResourceSurrogateId = A.ResourceSurrogateId)        OPTION (MAXDOP 1, OPTIMIZE FOR (@DummyTop = 1))    SET @AffectedRows += @@rowcount    INSERT INTO dbo.ReferenceSearchParam            ( ResourceTypeId, ResourceSurrogateId, SearchParamId, BaseUri, ReferenceResourceTypeId, ReferenceResourceId, ReferenceResourceVersion )      SELECT ResourceTypeId, ResourceSurrogateId, SearchParamId, BaseUri, ReferenceResourceTypeId, ReferenceResourceId, ReferenceResourceVersion        FROM (SELECT TOP (@DummyTop) * FROM @ReferenceSearchParams) A        WHERE EXISTS (SELECT * FROM @Existing B WHERE B.ResourceTypeId = A.ResourceTypeId AND B.SurrogateId = A.ResourceSurrogateId)          AND NOT EXISTS (SELECT * FROM dbo.ReferenceSearchParam C WHERE C.ResourceTypeId = A.ResourceTypeId AND C.ResourceSurrogateId = A.ResourceSurrogateId)        OPTION (MAXDOP 1, OPTIMIZE FOR (@DummyTop = 1))    SET @AffectedRows += @@rowcount    INSERT INTO dbo.TokenSearchParam            ( ResourceTypeId, ResourceSurrogateId, SearchParamId, SystemId, Code, CodeOverflow )      SELECT ResourceTypeId, ResourceSurrogateId, SearchParamId, SystemId, Code, CodeOverflow        FROM (SELECT TOP (@DummyTop) * FROM @TokenSearchParams) A        WHERE EXISTS (SELECT * FROM @Existing B WHERE B.ResourceTypeId = A.ResourceTypeId AND B.SurrogateId = A.ResourceSurrogateId)          AND NOT EXISTS (SELECT * FROM dbo.TokenSearchParam C WHERE C.ResourceTypeId = A.ResourceTypeId AND C.ResourceSurrogateId = A.ResourceSurrogateId)        OPTION (MAXDOP 1, OPTIMIZE FOR (@DummyTop = 1))    SET @AffectedRows += @@rowcount    INSERT INTO dbo.TokenText            ( ResourceTypeId, ResourceSurrogateId, SearchParamId, Text )      SELECT ResourceTypeId, ResourceSurrogateId, SearchParamId, Text        FROM (SELECT TOP (@DummyTop) * FROM @TokenTexts) A        WHERE EXISTS (SELECT * FROM @Existing B WHERE B.ResourceTypeId = A.ResourceTypeId AND B.SurrogateId = A.ResourceSurrogateId)          AND NOT EXISTS (SELECT * FROM dbo.TokenSearchParam C WHERE C.ResourceTypeId = A.ResourceTypeId AND C.ResourceSurrogateId = A.ResourceSurrogateId)        OPTION (MAXDOP 1, OPTIMIZE FOR (@DummyTop = 1))    SET @AffectedRows += @@rowcount    INSERT INTO dbo.StringSearchParam            ( ResourceTypeId, ResourceSurrogateId, SearchParamId, Text, TextOverflow, IsMin, IsMax )      SELECT ResourceTypeId, ResourceSurrogateId, SearchParamId, Text, TextOverflow, IsMin, IsMax        FROM (SELECT TOP (@DummyTop) * FROM @StringSearchParams) A        WHERE EXISTS (SELECT * FROM @Existing B WHERE B.ResourceTypeId = A.ResourceTypeId AND B.SurrogateId = A.ResourceSurrogateId)          AND NOT EXISTS (SELECT * FROM dbo.TokenText C WHERE C.ResourceTypeId = A.ResourceTypeId AND C.ResourceSurrogateId = A.ResourceSurrogateId)        OPTION (MAXDOP 1, OPTIMIZE FOR (@DummyTop = 1))    SET @AffectedRows += @@rowcount    INSERT INTO dbo.UriSearchParam            ( ResourceTypeId, ResourceSurrogateId, SearchParamId, Uri )      SELECT ResourceTypeId, ResourceSurrogateId, SearchParamId, Uri        FROM (SELECT TOP (@DummyTop) * FROM @UriSearchParams) A        WHERE EXISTS (SELECT * FROM @Existing B WHERE B.ResourceTypeId = A.ResourceTypeId AND B.SurrogateId = A.ResourceSurrogateId)          AND NOT EXISTS (SELECT * FROM dbo.UriSearchParam C WHERE C.ResourceTypeId = A.ResourceTypeId AND C.ResourceSurrogateId = A.ResourceSurrogateId)        OPTION (MAXDOP 1, OPTIMIZE FOR (@DummyTop = 1))    SET @AffectedRows += @@rowcount    INSERT INTO dbo.NumberSearchParam            ( ResourceTypeId, ResourceSurrogateId, SearchParamId, SingleValue, LowValue, HighValue )      SELECT ResourceTypeId, ResourceSurrogateId, SearchParamId, SingleValue, LowValue, HighValue        FROM (SELECT TOP (@DummyTop) * FROM @NumberSearchParams) A        WHERE EXISTS (SELECT * FROM @Existing B WHERE B.ResourceTypeId = A.ResourceTypeId AND B.SurrogateId = A.ResourceSurrogateId)          AND NOT EXISTS (SELECT * FROM dbo.NumberSearchParam C WHERE C.ResourceTypeId = A.ResourceTypeId AND C.ResourceSurrogateId = A.ResourceSurrogateId)        OPTION (MAXDOP 1, OPTIMIZE FOR (@DummyTop = 1))    SET @AffectedRows += @@rowcount    INSERT INTO dbo.QuantitySearchParam            ( ResourceTypeId, ResourceSurrogateId, SearchParamId, SystemId, QuantityCodeId, SingleValue, LowValue, HighValue )      SELECT ResourceTypeId, ResourceSurrogateId, SearchParamId, SystemId, QuantityCodeId, SingleValue, LowValue, HighValue        FROM (SELECT TOP (@DummyTop) * FROM @QuantitySearchParams) A        WHERE EXISTS (SELECT * FROM @Existing B WHERE B.ResourceTypeId = A.ResourceTypeId AND B.SurrogateId = A.ResourceSurrogateId)          AND NOT EXISTS (SELECT * FROM dbo.QuantitySearchParam C WHERE C.ResourceTypeId = A.ResourceTypeId AND C.ResourceSurrogateId = A.ResourceSurrogateId)        OPTION (MAXDOP 1, OPTIMIZE FOR (@DummyTop = 1))    SET @AffectedRows += @@rowcount    INSERT INTO dbo.DateTimeSearchParam            ( ResourceTypeId, ResourceSurrogateId, SearchParamId, StartDateTime, EndDateTime, IsLongerThanADay, IsMin, IsMax )      SELECT ResourceTypeId, ResourceSurrogateId, SearchParamId, StartDateTime, EndDateTime, IsLongerThanADay, IsMin, IsMax        FROM (SELECT TOP (@DummyTop) * FROM @DateTimeSearchParms) A        WHERE EXISTS (SELECT * FROM @Existing B WHERE B.ResourceTypeId = A.ResourceTypeId AND B.SurrogateId = A.ResourceSurrogateId)          AND NOT EXISTS (SELECT * FROM dbo.TokenSearchParam C WHERE C.ResourceTypeId = A.ResourceTypeId AND C.ResourceSurrogateId = A.ResourceSurrogateId)        OPTION (MAXDOP 1, OPTIMIZE FOR (@DummyTop = 1))    SET @AffectedRows += @@rowcount    INSERT INTO dbo.ReferenceTokenCompositeSearchParam            ( ResourceTypeId, ResourceSurrogateId, SearchParamId, BaseUri1, ReferenceResourceTypeId1, ReferenceResourceId1, ReferenceResourceVersion1, SystemId2, Code2, CodeOverflow2 )      SELECT ResourceTypeId, ResourceSurrogateId, SearchParamId, BaseUri1, ReferenceResourceTypeId1, ReferenceResourceId1, ReferenceResourceVersion1, SystemId2, Code2, CodeOverflow2        FROM (SELECT TOP (@DummyTop) * FROM @ReferenceTokenCompositeSearchParams) A        WHERE EXISTS (SELECT * FROM @Existing B WHERE B.ResourceTypeId = A.ResourceTypeId AND B.SurrogateId = A.ResourceSurrogateId)          AND NOT EXISTS (SELECT * FROM dbo.DateTimeSearchParam C WHERE C.ResourceTypeId = A.ResourceTypeId AND C.ResourceSurrogateId = A.ResourceSurrogateId)        OPTION (MAXDOP 1, OPTIMIZE FOR (@DummyTop = 1))    SET @AffectedRows += @@rowcount    INSERT INTO dbo.TokenTokenCompositeSearchParam            ( ResourceTypeId, ResourceSurrogateId, SearchParamId, SystemId1, Code1, CodeOverflow1, SystemId2, Code2, CodeOverflow2 )      SELECT ResourceTypeId, ResourceSurrogateId, SearchParamId, SystemId1, Code1, CodeOverflow1, SystemId2, Code2, CodeOverflow2        FROM (SELECT TOP (@DummyTop) * FROM @TokenTokenCompositeSearchParams) A        WHERE EXISTS (SELECT * FROM @Existing B WHERE B.ResourceTypeId = A.ResourceTypeId AND B.SurrogateId = A.ResourceSurrogateId)          AND NOT EXISTS (SELECT * FROM dbo.TokenTokenCompositeSearchParam C WHERE C.ResourceTypeId = A.ResourceTypeId AND C.ResourceSurrogateId = A.ResourceSurrogateId)        OPTION (MAXDOP 1, OPTIMIZE FOR (@DummyTop = 1))    SET @AffectedRows += @@rowcount    INSERT INTO dbo.TokenDateTimeCompositeSearchParam            ( ResourceTypeId, ResourceSurrogateId, SearchParamId, SystemId1, Code1, CodeOverflow1, StartDateTime2, EndDateTime2, IsLongerThanADay2 )      SELECT ResourceTypeId, ResourceSurrogateId, SearchParamId, SystemId1, Code1, CodeOverflow1, StartDateTime2, EndDateTime2, IsLongerThanADay2        FROM (SELECT TOP (@DummyTop) * FROM @TokenDateTimeCompositeSearchParams) A        WHERE EXISTS (SELECT * FROM @Existing B WHERE B.ResourceTypeId = A.ResourceTypeId AND B.SurrogateId = A.ResourceSurrogateId)          AND NOT EXISTS (SELECT * FROM dbo.TokenDateTimeCompositeSearchParam C WHERE C.ResourceTypeId = A.ResourceTypeId AND C.ResourceSurrogateId = A.ResourceSurrogateId)        OPTION (MAXDOP 1, OPTIMIZE FOR (@DummyTop = 1))    SET @AffectedRows += @@rowcount    INSERT INTO dbo.TokenQuantityCompositeSearchParam            ( ResourceTypeId, ResourceSurrogateId, SearchParamId, SystemId1, Code1, CodeOverflow1, SingleValue2, SystemId2, QuantityCodeId2, LowValue2, HighValue2 )      SELECT ResourceTypeId, ResourceSurrogateId, SearchParamId, SystemId1, Code1, CodeOverflow1, SingleValue2, SystemId2, QuantityCodeId2, LowValue2, HighValue2        FROM (SELECT TOP (@DummyTop) * FROM @TokenQuantityCompositeSearchParams) A        WHERE EXISTS (SELECT * FROM @Existing B WHERE B.ResourceTypeId = A.ResourceTypeId AND B.SurrogateId = A.ResourceSurrogateId)          AND NOT EXISTS (SELECT * FROM dbo.TokenQuantityCompositeSearchParam C WHERE C.ResourceTypeId = A.ResourceTypeId AND C.ResourceSurrogateId = A.ResourceSurrogateId)        OPTION (MAXDOP 1, OPTIMIZE FOR (@DummyTop = 1))    SET @AffectedRows += @@rowcount    INSERT INTO dbo.TokenStringCompositeSearchParam            ( ResourceTypeId, ResourceSurrogateId, SearchParamId, SystemId1, Code1, CodeOverflow1, Text2, TextOverflow2 )      SELECT ResourceTypeId, ResourceSurrogateId, SearchParamId, SystemId1, Code1, CodeOverflow1, Text2, TextOverflow2        FROM (SELECT TOP (@DummyTop) * FROM @TokenStringCompositeSearchParams) A        WHERE EXISTS (SELECT * FROM @Existing B WHERE B.ResourceTypeId = A.ResourceTypeId AND B.SurrogateId = A.ResourceSurrogateId)          AND NOT EXISTS (SELECT * FROM dbo.TokenStringCompositeSearchParam C WHERE C.ResourceTypeId = A.ResourceTypeId AND C.ResourceSurrogateId = A.ResourceSurrogateId)        OPTION (MAXDOP 1, OPTIMIZE FOR (@DummyTop = 1))    SET @AffectedRows += @@rowcount    INSERT INTO dbo.TokenNumberNumberCompositeSearchParam            ( ResourceTypeId, ResourceSurrogateId, SearchParamId, SystemId1, Code1, CodeOverflow1, SingleValue2, LowValue2, HighValue2, SingleValue3, LowValue3, HighValue3, HasRange )      SELECT ResourceTypeId, ResourceSurrogateId, SearchParamId, SystemId1, Code1, CodeOverflow1, SingleValue2, LowValue2, HighValue2, SingleValue3, LowValue3, HighValue3, HasRange        FROM (SELECT TOP (@DummyTop) * FROM @TokenNumberNumberCompositeSearchParams) A        WHERE EXISTS (SELECT * FROM @Existing B WHERE B.ResourceTypeId = A.ResourceTypeId AND B.SurrogateId = A.ResourceSurrogateId)          AND NOT EXISTS (SELECT * FROM dbo.TokenNumberNumberCompositeSearchParam C WHERE C.ResourceTypeId = A.ResourceTypeId AND C.ResourceSurrogateId = A.ResourceSurrogateId)        OPTION (MAXDOP 1, OPTIMIZE FOR (@DummyTop = 1))    SET @AffectedRows += @@rowcount  END  IF @IsResourceChangeCaptureEnabled = 1 --If the resource change capture feature is enabled, to execute a stored procedure called CaptureResourceChanges to insert resource change data.    EXECUTE dbo.CaptureResourceIdsForChanges @Resources  IF @TransactionId IS NOT NULL    EXECUTE dbo.MergeResourcesCommitTransaction @TransactionId  IF @InitialTranCount = 0 AND @@trancount > 0 COMMIT TRANSACTION  EXECUTE dbo.LogEvent @Process=@SP,@Mode=@Mode,@Status='End',@Start=@st,@Rows=@AffectedRowsEND TRYBEGIN CATCH  IF @InitialTranCount = 0 AND @@trancount > 0 ROLLBACK TRANSACTION  IF error_number() = 1750 THROW -- Real error is before 1750, cannot trap in SQL.  EXECUTE dbo.LogEvent @Process=@SP,@Mode=@Mode,@Status='Error',@Start=@st;  IF @RaiseExceptionOnConflict = 1 AND error_number() IN (2601, 2627) AND (error_message() LIKE '%''dbo.Resource''%' OR error_message() LIKE '%''dbo.ResourceCurrent''%' OR error_message() LIKE '%''dbo.ResourceHistory''%') -- handles old and separated tables    THROW 50409, 'Resource has been recently updated or added, please compare the resource content in code for any duplicate updates', 1;  ELSE    THROWEND CATCHGOEXECUTE dbo.LogEvent @Process='HistorySeparation',@Status='Run',@Target='MergeResources',@Action='Alter'GOALTER PROCEDURE dbo.UpdateResourceSearchParams    @FailedResources int = 0 OUT   ,@Resources dbo.ResourceList READONLY   ,@ResourceWriteClaims dbo.ResourceWriteClaimList READONLY   ,@ReferenceSearchParams dbo.ReferenceSearchParamList READONLY   ,@TokenSearchParams dbo.TokenSearchParamList READONLY   ,@TokenTexts dbo.TokenTextList READONLY   ,@StringSearchParams dbo.StringSearchParamList READONLY   ,@UriSearchParams dbo.UriSearchParamList READONLY   ,@NumberSearchParams dbo.NumberSearchParamList READONLY   ,@QuantitySearchParams dbo.QuantitySearchParamList READONLY   ,@DateTimeSearchParams dbo.DateTimeSearchParamList READONLY   ,@ReferenceTokenCompositeSearchParams dbo.ReferenceTokenCompositeSearchParamList READONLY   ,@TokenTokenCompositeSearchParams dbo.TokenTokenCompositeSearchParamList READONLY   ,@TokenDateTimeCompositeSearchParams dbo.TokenDateTimeCompositeSearchParamList READONLY   ,@TokenQuantityCompositeSearchParams dbo.TokenQuantityCompositeSearchParamList READONLY   ,@TokenStringCompositeSearchParams dbo.TokenStringCompositeSearchParamList READONLY   ,@TokenNumberNumberCompositeSearchParams dbo.TokenNumberNumberCompositeSearchParamList READONLYASset nocount onDECLARE @st datetime = getUTCdate()       ,@SP varchar(100) = object_name(@@procid)       ,@Mode varchar(200) = isnull((SELECT 'RT=['+convert(varchar,min(ResourceTypeId))+','+convert(varchar,max(ResourceTypeId))+'] Sur=['+convert(varchar,min(ResourceSurrogateId))+','+convert(varchar,max(ResourceSurrogateId))+'] V='+convert(varchar,max(Version))+' Rows='+convert(varchar,count(*)) FROM @Resources),'Input=Empty')       ,@Rows intBEGIN TRY  DECLARE @Ids TABLE (ResourceTypeId smallint NOT NULL, ResourceSurrogateId bigint NOT NULL)  BEGIN TRANSACTION  -- Update the search parameter hash value in the main resource table  -- Avoid join to enable update via view  UPDATE A    SET SearchParamHash = (SELECT SearchParamHash FROM @Resources B WHERE B.ResourceTypeId = A.ResourceTypeId AND B.ResourceSurrogateId = A.ResourceSurrogateId)    FROM dbo.Resource A    WHERE IsHistory = 0      AND EXISTS (SELECT * FROM @Resources B WHERE B.ResourceTypeId = A.ResourceTypeId AND B.ResourceSurrogateId = A.ResourceSurrogateId)  SET @Rows = @@rowcount  -- First, delete all the search params of the resources to reindex.  DELETE FROM B FROM @Ids A JOIN dbo.ResourceWriteClaim B ON B.ResourceSurrogateId = A.ResourceSurrogateId  DELETE FROM B FROM @Ids A JOIN dbo.ReferenceSearchParam B ON B.ResourceTypeId = A.ResourceTypeId AND B.ResourceSurrogateId = A.ResourceSurrogateId  DELETE FROM B FROM @Ids A JOIN dbo.TokenSearchParam B ON B.ResourceTypeId = A.ResourceTypeId AND B.ResourceSurrogateId = A.ResourceSurrogateId  DELETE FROM B FROM @Ids A JOIN dbo.TokenText B ON B.ResourceTypeId = A.ResourceTypeId AND B.ResourceSurrogateId = A.ResourceSurrogateId  DELETE FROM B FROM @Ids A JOIN dbo.StringSearchParam B ON B.ResourceTypeId = A.ResourceTypeId AND B.ResourceSurrogateId = A.ResourceSurrogateId  DELETE FROM B FROM @Ids A JOIN dbo.UriSearchParam B ON B.ResourceTypeId = A.ResourceTypeId AND B.ResourceSurrogateId = A.ResourceSurrogateId  DELETE FROM B FROM @Ids A JOIN dbo.NumberSearchParam B ON B.ResourceTypeId = A.ResourceTypeId AND B.ResourceSurrogateId = A.ResourceSurrogateId  DELETE FROM B FROM @Ids A JOIN dbo.QuantitySearchParam B ON B.ResourceTypeId = A.ResourceTypeId AND B.ResourceSurrogateId = A.ResourceSurrogateId  DELETE FROM B FROM @Ids A JOIN dbo.DateTimeSearchParam B ON B.ResourceTypeId = A.ResourceTypeId AND B.ResourceSurrogateId = A.ResourceSurrogateId  DELETE FROM B FROM @Ids A JOIN dbo.ReferenceTokenCompositeSearchParam B ON B.ResourceTypeId = A.ResourceTypeId AND B.ResourceSurrogateId = A.ResourceSurrogateId  DELETE FROM B FROM @Ids A JOIN dbo.TokenTokenCompositeSearchParam B ON B.ResourceTypeId = A.ResourceTypeId AND B.ResourceSurrogateId = A.ResourceSurrogateId  DELETE FROM B FROM @Ids A JOIN dbo.TokenDateTimeCompositeSearchParam B ON B.ResourceTypeId = A.ResourceTypeId AND B.ResourceSurrogateId = A.ResourceSurrogateId  DELETE FROM B FROM @Ids A JOIN dbo.TokenQuantityCompositeSearchParam B ON B.ResourceTypeId = A.ResourceTypeId AND B.ResourceSurrogateId = A.ResourceSurrogateId  DELETE FROM B FROM @Ids A JOIN dbo.TokenStringCompositeSearchParam B ON B.ResourceTypeId = A.ResourceTypeId AND B.ResourceSurrogateId = A.ResourceSurrogateId  DELETE FROM B FROM @Ids A JOIN dbo.TokenNumberNumberCompositeSearchParam B ON B.ResourceTypeId = A.ResourceTypeId AND B.ResourceSurrogateId = A.ResourceSurrogateId  -- Next, insert all the new search params.  INSERT INTO dbo.ResourceWriteClaim          ( ResourceSurrogateId, ClaimTypeId, ClaimValue )    SELECT ResourceSurrogateId, ClaimTypeId, ClaimValue      FROM @ResourceWriteClaims  INSERT INTO dbo.ReferenceSearchParam          ( ResourceTypeId, ResourceSurrogateId, SearchParamId, BaseUri, ReferenceResourceTypeId, ReferenceResourceId, ReferenceResourceVersion )    SELECT ResourceTypeId, ResourceSurrogateId, SearchParamId, BaseUri, ReferenceResourceTypeId, ReferenceResourceId, ReferenceResourceVersion      FROM @ReferenceSearchParams  INSERT INTO dbo.TokenSearchParam          ( ResourceTypeId, ResourceSurrogateId, SearchParamId, SystemId, Code, CodeOverflow )    SELECT ResourceTypeId, ResourceSurrogateId, SearchParamId, SystemId, Code, CodeOverflow      FROM @TokenSearchParams  INSERT INTO dbo.TokenText          ( ResourceTypeId, ResourceSurrogateId, SearchParamId, Text )    SELECT ResourceTypeId, ResourceSurrogateId, SearchParamId, Text      FROM @TokenTexts  INSERT INTO dbo.StringSearchParam          ( ResourceTypeId, ResourceSurrogateId, SearchParamId, Text, TextOverflow, IsMin, IsMax )    SELECT ResourceTypeId, ResourceSurrogateId, SearchParamId, Text, TextOverflow, IsMin, IsMax      FROM @StringSearchParams  INSERT INTO dbo.UriSearchParam          ( ResourceTypeId, ResourceSurrogateId, SearchParamId, Uri )    SELECT ResourceTypeId, ResourceSurrogateId, SearchParamId, Uri      FROM @UriSearchParams  INSERT INTO dbo.NumberSearchParam          ( ResourceTypeId, ResourceSurrogateId, SearchParamId, SingleValue, LowValue, HighValue )    SELECT ResourceTypeId, ResourceSurrogateId, SearchParamId, SingleValue, LowValue, HighValue      FROM @NumberSearchParams  INSERT INTO dbo.QuantitySearchParam          ( ResourceTypeId, ResourceSurrogateId, SearchParamId, SystemId, QuantityCodeId, SingleValue, LowValue, HighValue )    SELECT ResourceTypeId, ResourceSurrogateId, SearchParamId, SystemId, QuantityCodeId, SingleValue, LowValue, HighValue      FROM @QuantitySearchParams  INSERT INTO dbo.DateTimeSearchParam          ( ResourceTypeId, ResourceSurrogateId, SearchParamId, StartDateTime, EndDateTime, IsLongerThanADay, IsMin, IsMax )    SELECT ResourceTypeId, ResourceSurrogateId, SearchParamId, StartDateTime, EndDateTime, IsLongerThanADay, IsMin, IsMax      FROM @DateTimeSearchParams  INSERT INTO dbo.ReferenceTokenCompositeSearchParam          ( ResourceTypeId, ResourceSurrogateId, SearchParamId, BaseUri1, ReferenceResourceTypeId1, ReferenceResourceId1, ReferenceResourceVersion1, SystemId2, Code2, CodeOverflow2 )    SELECT ResourceTypeId, ResourceSurrogateId, SearchParamId, BaseUri1, ReferenceResourceTypeId1, ReferenceResourceId1, ReferenceResourceVersion1, SystemId2, Code2, CodeOverflow2      FROM @ReferenceTokenCompositeSearchParams  INSERT INTO dbo.TokenTokenCompositeSearchParam          ( ResourceTypeId, ResourceSurrogateId, SearchParamId, SystemId1, Code1, CodeOverflow1, SystemId2, Code2, CodeOverflow2 )    SELECT ResourceTypeId, ResourceSurrogateId, SearchParamId, SystemId1, Code1, CodeOverflow1, SystemId2, Code2, CodeOverflow2      FROM @TokenTokenCompositeSearchParams  INSERT INTO dbo.TokenDateTimeCompositeSearchParam          ( ResourceTypeId, ResourceSurrogateId, SearchParamId, SystemId1, Code1, CodeOverflow1, StartDateTime2, EndDateTime2, IsLongerThanADay2 )    SELECT ResourceTypeId, ResourceSurrogateId, SearchParamId, SystemId1, Code1, CodeOverflow1, StartDateTime2, EndDateTime2, IsLongerThanADay2      FROM @TokenDateTimeCompositeSearchParams  INSERT INTO dbo.TokenQuantityCompositeSearchParam          ( ResourceTypeId, ResourceSurrogateId, SearchParamId, SystemId1, Code1, CodeOverflow1, SingleValue2, SystemId2, QuantityCodeId2, LowValue2, HighValue2 )    SELECT ResourceTypeId, ResourceSurrogateId, SearchParamId, SystemId1, Code1, CodeOverflow1, SingleValue2, SystemId2, QuantityCodeId2, LowValue2, HighValue2      FROM @TokenQuantityCompositeSearchParams  INSERT INTO dbo.TokenStringCompositeSearchParam          ( ResourceTypeId, ResourceSurrogateId, SearchParamId, SystemId1, Code1, CodeOverflow1, Text2, TextOverflow2 )    SELECT ResourceTypeId, ResourceSurrogateId, SearchParamId, SystemId1, Code1, CodeOverflow1, Text2, TextOverflow2      FROM @TokenStringCompositeSearchParams  INSERT INTO dbo.TokenNumberNumberCompositeSearchParam          ( ResourceTypeId, ResourceSurrogateId, SearchParamId, SystemId1, Code1, CodeOverflow1, SingleValue2, LowValue2, HighValue2, SingleValue3, LowValue3, HighValue3, HasRange )    SELECT ResourceTypeId, ResourceSurrogateId, SearchParamId, SystemId1, Code1, CodeOverflow1, SingleValue2, LowValue2, HighValue2, SingleValue3, LowValue3, HighValue3, HasRange      FROM @TokenNumberNumberCompositeSearchParams  COMMIT TRANSACTION  SET @FailedResources = (SELECT count(*) FROM @Resources) - @Rows  EXECUTE dbo.LogEvent @Process=@SP,@Mode=@Mode,@Status='End',@Start=@st,@Rows=@RowsEND TRYBEGIN CATCH  IF @@trancount > 0 ROLLBACK TRANSACTION  EXECUTE dbo.LogEvent @Process=@SP,@Mode=@Mode,@Status='Error',@Start=@st;  THROWEND CATCHGOEXECUTE dbo.LogEvent @Process='HistorySeparation',@Status='Run',@Target='UpdateResourceSearchParams',@Action='Alter'GOALTER PROCEDURE dbo.DisableIndexesWITH EXECUTE AS 'dbo'ASset nocount onDECLARE @SP varchar(100) = 'DisableIndexes'       ,@Mode varchar(200) = ''       ,@st datetime = getUTCdate()       ,@Tbl varchar(100)       ,@Ind varchar(200)       ,@Txt varchar(4000)BEGIN TRY  EXECUTE dbo.LogEvent @Process=@SP,@Mode=@Mode,@Status='Start'  DECLARE @Tables TABLE (Tbl varchar(100) PRIMARY KEY, Supported bit)  INSERT INTO @Tables EXECUTE dbo.GetPartitionedTables @IncludeNotDisabled = 1, @IncludeNotSupported = 0  EXECUTE dbo.LogEvent @Process=@SP,@Mode=@Mode,@Status='Info',@Target='@Tables',@Action='Insert',@Rows=@@rowcount  DECLARE @Indexes TABLE (Tbl varchar(100), Ind varchar(200), TblId int, IndId int PRIMARY KEY (Tbl, Ind))  INSERT INTO @Indexes    SELECT Tbl          ,I.Name          ,TblId          ,I.index_id      FROM (SELECT TblId = object_id(Tbl), Tbl FROM @Tables) O           JOIN sys.indexes I ON I.object_id = TblId  EXECUTE dbo.LogEvent @Process=@SP,@Mode=@Mode,@Status='Info',@Target='@Indexes',@Action='Insert',@Rows=@@rowcount  INSERT INTO dbo.IndexProperties          ( TableName, IndexName,       PropertyName, PropertyValue )     SELECT       Tbl,       Ind, 'DATA_COMPRESSION',     data_comp      FROM (SELECT Tbl                  ,Ind                  ,data_comp = isnull((SELECT TOP 1 CASE WHEN data_compression_desc = 'PAGE' THEN 'PAGE' END FROM sys.partitions WHERE object_id = TblId AND index_id = IndId),'NONE')              FROM @Indexes           ) A      WHERE NOT EXISTS (SELECT * FROM dbo.IndexProperties WHERE TableName = Tbl AND IndexName = Ind)  EXECUTE dbo.LogEvent @Process=@SP,@Mode=@Mode,@Status='Info',@Target='IndexProperties',@Action='Insert',@Rows=@@rowcount  DELETE FROM @Indexes WHERE Tbl IN ('Resource','ResourceCurrent','ResourceHistory') OR IndId = 1  EXECUTE dbo.LogEvent @Process=@SP,@Mode=@Mode,@Status='Info',@Target='@Indexes',@Action='Delete',@Rows=@@rowcount  WHILE EXISTS (SELECT * FROM @Indexes)  BEGIN    SELECT TOP 1 @Tbl = Tbl, @Ind = Ind FROM @Indexes    SET @Txt = 'ALTER INDEX '+@Ind+' ON dbo.'+@Tbl+' DISABLE'    EXECUTE(@Txt)    EXECUTE dbo.LogEvent @Process=@SP,@Mode=@Mode,@Status='Info',@Target=@Ind,@Action='Disable',@Text=@Txt    DELETE FROM @Indexes WHERE Tbl = @Tbl AND Ind = @Ind  END  EXECUTE dbo.LogEvent @Process=@SP,@Mode=@Mode,@Status='End',@Start=@stEND TRYBEGIN CATCH  IF error_number() = 1750 THROW -- Real error is before 1750, cannot trap in SQL.  EXECUTE dbo.LogEvent @Process=@SP,@Mode=@Mode,@Status='Error',@Start=@st;  THROWEND CATCHGOEXECUTE dbo.LogEvent @Process='HistorySeparation',@Status='Run',@Target='DisableIndexes',@Action='Alter'GOIF object_id('dbo.ResourceCurrent') IS NULLBEGIN  BEGIN TRY    BEGIN TRANSACTION    CREATE TABLE dbo.ResourceCurrent    (        ResourceTypeId              smallint                NOT NULL       ,ResourceSurrogateId         bigint                  NOT NULL       ,ResourceId                  varchar(64)             COLLATE Latin1_General_100_CS_AS NOT NULL       ,Version                     int                     NOT NULL       ,IsHistory                   bit                     NOT NULL CONSTRAINT DF_ResourceCurrent_IsHistory DEFAULT 0, CONSTRAINT CH_ResourceCurrent_IsHistory CHECK (IsHistory = 0)       ,IsDeleted                   bit                     NOT NULL       ,RequestMethod               varchar(10)             NULL       ,RawResource                 varbinary(max)          NOT NULL CONSTRAINT CH_ResourceCurrent_RawResource_Length CHECK (RawResource > 0x0)       ,IsRawResourceMetaSet        bit                     NOT NULL CONSTRAINT DF_ResourceCurrent_IsRawResourceMetaSet DEFAULT 0       ,SearchParamHash             varchar(64)             NULL       ,TransactionId               bigint                  NULL      -- used for main CRUD operation         CONSTRAINT PKC_ResourceCurrent_ResourceTypeId_ResourceSurrogateId PRIMARY KEY CLUSTERED (ResourceTypeId, ResourceSurrogateId) WITH (DATA_COMPRESSION = PAGE) ON PartitionScheme_ResourceTypeId (ResourceTypeId)       ,CONSTRAINT U_ResourceCurrent_ResourceTypeId_ResourceId UNIQUE (ResourceTypeId, ResourceId) ON PartitionScheme_ResourceTypeId (ResourceTypeId)    )    ALTER TABLE dbo.ResourceCurrent SET ( LOCK_ESCALATION = AUTO )    CREATE UNIQUE INDEX IXU_ResourceTypeId_ResourceSurrogateId_WHERE_IsHistory_0_IsDeleted_0 ON dbo.ResourceCurrent (ResourceTypeId, ResourceSurrogateId) WHERE IsHistory = 0 AND IsDeleted = 0 ON PartitionScheme_ResourceTypeId (ResourceTypeId)    CREATE INDEX IX_ResourceTypeId_TransactionId_WHERE_TransactionId_NOT_NULL ON dbo.ResourceCurrent (ResourceTypeId, TransactionId) WHERE TransactionId IS NOT NULL ON PartitionScheme_ResourceTypeId (ResourceTypeId)    EXECUTE dbo.LogEvent @Process='HistorySeparation',@Status='Run',@Target='ResourceCurrent',@Action='Create'    CREATE TABLE dbo.ResourceHistory    (        ResourceTypeId              smallint                NOT NULL       ,ResourceSurrogateId         bigint                  NOT NULL       ,ResourceId                  varchar(64)             COLLATE Latin1_General_100_CS_AS NOT NULL       ,Version                     int                     NOT NULL       ,IsHistory                   bit                     NOT NULL CONSTRAINT DF_ResourceHistory_IsHistory DEFAULT 1, CONSTRAINT CH_ResourceHistory_IsHistory CHECK (IsHistory = 1)       ,IsDeleted                   bit                     NOT NULL       ,RequestMethod               varchar(10)             NULL       ,RawResource                 varbinary(max)          NOT NULL CONSTRAINT CH_ResourceHistory_RawResource_Length CHECK (RawResource > 0x0)       ,IsRawResourceMetaSet        bit                     NOT NULL CONSTRAINT DF_ResourceHistory_IsRawResourceMetaSet DEFAULT 0       ,SearchParamHash             varchar(64)             NULL       ,TransactionId               bigint                  NULL      -- used for main CRUD operation        ,HistoryTransactionId        bigint                  NULL      -- used by CRUD operation that moved resource version in invisible state         CONSTRAINT PKC_ResourceHistory_ResourceTypeId_ResourceSurrogateId PRIMARY KEY CLUSTERED (ResourceTypeId, ResourceSurrogateId) WITH (DATA_COMPRESSION = PAGE) ON PartitionScheme_ResourceTypeId (ResourceTypeId)       ,CONSTRAINT U_ResourceHistory_ResourceTypeId_ResourceId_Version UNIQUE (ResourceTypeId, ResourceId, Version) ON PartitionScheme_ResourceTypeId (ResourceTypeId)    )    ALTER TABLE dbo.ResourceHistory SET ( LOCK_ESCALATION = AUTO )    CREATE INDEX IX_ResourceTypeId_TransactionId_WHERE_TransactionId_NOT_NULL ON dbo.ResourceHistory (ResourceTypeId, TransactionId) WHERE TransactionId IS NOT NULL ON PartitionScheme_ResourceTypeId (ResourceTypeId)    CREATE INDEX IX_ResourceTypeId_HistoryTransactionId_WHERE_HistoryTransactionId_NOT_NULL ON dbo.ResourceHistory (ResourceTypeId, HistoryTransactionId) WHERE HistoryTransactionId IS NOT NULL ON PartitionScheme_ResourceTypeId (ResourceTypeId)    EXECUTE dbo.LogEvent @Process='HistorySeparation',@Status='Run',@Target='ResourceHistory',@Action='Create'    COMMIT TRANSACTION  END TRY  BEGIN CATCH    ROLLBACK TRANSACTION    EXECUTE dbo.LogEvent @Process='HistorySeparation',@Status='Error';    THROW   END CATCHENDGOIF EXISTS (SELECT * FROM sys.objects WHERE object_id = object_id('dbo.Resource') AND type = 'u')   AND NOT EXISTS (SELECT * FROM dbo.Parameters WHERE Id = 'SkipHistorySeparation' AND Number = 1)BEGIN  --CREATE TRIGGER dbo.ResourceIns  EXECUTE('CREATE OR ALTER TRIGGER dbo.ResourceIns ON dbo.Resource AFTER INSERTASBEGIN  INSERT INTO dbo.ResourceCurrent      (           ResourceTypeId          ,ResourceSurrogateId          ,ResourceId          ,Version          ,IsDeleted          ,RequestMethod          ,RawResource          ,IsRawResourceMetaSet          ,SearchParamHash          ,TransactionId      )    SELECT ResourceTypeId          ,ResourceSurrogateId          ,ResourceId          ,Version          ,IsDeleted          ,RequestMethod          ,RawResource          ,IsRawResourceMetaSet          ,SearchParamHash          ,TransactionId      FROM Inserted      WHERE IsHistory = 0  INSERT INTO dbo.ResourceHistory      (           ResourceTypeId          ,ResourceSurrogateId          ,ResourceId          ,Version          ,IsDeleted          ,RequestMethod          ,RawResource          ,IsRawResourceMetaSet          ,SearchParamHash          ,TransactionId          ,HistoryTransactionId      )    SELECT ResourceTypeId          ,ResourceSurrogateId          ,ResourceId          ,Version          ,IsDeleted          ,RequestMethod          ,RawResource          ,IsRawResourceMetaSet          ,SearchParamHash          ,TransactionId          ,HistoryTransactionId      FROM Inserted      WHERE IsHistory = 1END  ')  EXECUTE dbo.LogEvent @Process='HistorySeparation',@Status='Run',@Target='ResourceIns',@Action='Create'  --CREATE TRIGGER dbo.ResourceUpd  EXECUTE('CREATE OR ALTER TRIGGER dbo.ResourceUpd ON dbo.Resource AFTER UPDATEASBEGIN  UPDATE B    SET SearchParamHash = A.SearchParamHash -- this is the only update we support    FROM Inserted A         JOIN dbo.ResourceCurrent B ON B.ResourceTypeId = A.ResourceTypeId AND B.ResourceSurrogateId = A.ResourceSurrogateId    WHERE A.IsHistory = 0  DELETE FROM A    FROM dbo.ResourceCurrent A    WHERE EXISTS (SELECT * FROM Inserted B WHERE B.ResourceTypeId = A.ResourceTypeId AND B.ResourceSurrogateId = A.ResourceSurrogateId AND B.IsHistory = 1)  INSERT INTO dbo.ResourceHistory      (           ResourceTypeId          ,ResourceSurrogateId          ,ResourceId          ,Version          ,IsDeleted          ,RequestMethod          ,RawResource          ,IsRawResourceMetaSet          ,SearchParamHash          ,TransactionId          ,HistoryTransactionId      )    SELECT ResourceTypeId          ,ResourceSurrogateId          ,ResourceId          ,Version          ,IsDeleted          ,RequestMethod          ,RawResource          ,IsRawResourceMetaSet          ,SearchParamHash          ,TransactionId          ,HistoryTransactionId      FROM Inserted      WHERE IsHistory = 1END  ')  EXECUTE dbo.LogEvent @Process='HistorySeparation',@Status='Run',@Target='ResourceUpd',@Action='Create'  --CREATE TRIGGER dbo.ResourceDel  EXECUTE('CREATE OR ALTER TRIGGER dbo.ResourceDel ON dbo.Resource AFTER DELETEASBEGIN  DELETE FROM A    FROM dbo.ResourceCurrent A    WHERE EXISTS (SELECT * FROM Deleted B WHERE B.ResourceTypeId = A.ResourceTypeId AND B.ResourceSurrogateId = A.ResourceSurrogateId AND B.IsHistory = 0)  DELETE FROM A    FROM dbo.ResourceHistory A    WHERE EXISTS (SELECT * FROM Deleted B WHERE B.ResourceTypeId = A.ResourceTypeId AND B.ResourceSurrogateId = A.ResourceSurrogateId AND B.IsHistory = 1)END  ')  EXECUTE dbo.LogEvent @Process='HistorySeparation',@Status='Run',@Target='ResourceDel',@Action='Create'  DECLARE @Types TABLE (ResourceTypeId smallint PRIMARY KEY, Name varchar(100))  DECLARE @MaxSurrogateId bigint = 0         ,@ResourceTypeId smallint  IF NOT EXISTS (SELECT * FROM dbo.Parameters WHERE Id = 'HistorySeparation.MaxSurrogateId') -- DELETE FROM dbo.Parameters WHERE Id = 'HistorySeparation.MaxSurrogateId'  BEGIN    DECLARE @MaxSurrogateIdTmp bigint    INSERT INTO @Types EXECUTE dbo.GetUsedResourceTypes    WHILE EXISTS (SELECT * FROM @Types)    BEGIN      SET @ResourceTypeId = (SELECT TOP 1 ResourceTypeId FROM @Types)      SET @MaxSurrogateIdTmp = (SELECT max(ResourceSurrogateId) FROM Resource WHERE ResourceTypeId = @ResourceTypeId)      IF @MaxSurrogateIdTmp > @MaxSurrogateId SET @MaxSurrogateId = @MaxSurrogateIdTmp      DELETE FROM @Types WHERE ResourceTypeId = @ResourceTypeId    END    INSERT INTO dbo.Parameters (Id, Bigint) SELECT 'HistorySeparation.MaxSurrogateId', @MaxSurrogateId  END    SET @MaxSurrogateId = (SELECT Bigint FROM dbo.Parameters WHERE Id = 'HistorySeparation.MaxSurrogateId')  EXECUTE dbo.LogEvent @Process='HistorySeparation',@Status='Run',@Target='@MaxSurrogateId',@Action='Select',@Text=@MaxSurrogateId  -- Copy start ----------------------------------------------------------------------------------------------------------  DECLARE @Process varchar(100) = 'HistorySeparation.CopyResources'         ,@Id varchar(100) = 'HistorySeparation.CopyResources.LastProcessed.TypeId.SurrogateId'         ,@SurrogateId bigint         ,@RowsToProcess int         ,@ProcessedResources int         ,@ReportDate datetime = getUTCdate()         ,@DummyTop bigint = 9223372036854775807         ,@Rows int         ,@CurrentMaxSurrogateId bigint         ,@LastProcessed varchar(100)         ,@st datetime  BEGIN TRY    INSERT INTO dbo.Parameters (Id, Char) SELECT @Process, 'LogEvent'    EXECUTE dbo.LogEvent @Process=@Process,@Status='Start'    INSERT INTO dbo.Parameters (Id, Char) SELECT @Id, '0.0' WHERE NOT EXISTS (SELECT * FROM dbo.Parameters WHERE Id = @Id)    SET @LastProcessed = (SELECT Char FROM dbo.Parameters WHERE Id = @Id)    INSERT INTO @Types EXECUTE dbo.GetUsedResourceTypes    EXECUTE dbo.LogEvent @Process=@Process,@Status='Run',@Target='@Types',@Action='Insert',@Rows=@@rowcount    SET @ResourceTypeId = substring(@LastProcessed, 1, charindex('.', @LastProcessed) - 1) -- (SELECT value FROM string_split(@LastProcessed, '.', 1) WHERE ordinal = 1)    SET @SurrogateId = substring(@LastProcessed, charindex('.', @LastProcessed) + 1, 255) -- (SELECT value FROM string_split(@LastProcessed, '.', 1) WHERE ordinal = 2)    DELETE FROM @Types WHERE ResourceTypeId < @ResourceTypeId    EXECUTE dbo.LogEvent @Process=@Process,@Status='Run',@Target='@Types',@Action='Delete',@Rows=@@rowcount    WHILE EXISTS (SELECT * FROM @Types) -- Processing in ASC order    BEGIN      SET @ResourceTypeId = (SELECT TOP 1 ResourceTypeId FROM @Types ORDER BY ResourceTypeId)      SET @ProcessedResources = 0      SET @CurrentMaxSurrogateId = 0      WHILE @CurrentMaxSurrogateId IS NOT NULL      BEGIN        BEGIN TRANSACTION        SET @CurrentMaxSurrogateId = NULL        SELECT @CurrentMaxSurrogateId = max(ResourceSurrogateId), @RowsToProcess = count(*)          FROM (SELECT TOP 5000 ResourceSurrogateId -- 5000 is max to avoid lock escalation                  FROM dbo.Resource (HOLDLOCK) -- Hold locks for the duration of 2 inserts, so other write transactions cannot change data                  WHERE ResourceTypeId = @ResourceTypeId AND ResourceSurrogateId > @SurrogateId AND ResourceSurrogateId <= @MaxSurrogateId                   ORDER BY ResourceSurrogateId               ) A        IF @CurrentMaxSurrogateId IS NOT NULL        BEGIN          SET @LastProcessed = convert(varchar,@ResourceTypeId)+'.'+convert(varchar,@CurrentMaxSurrogateId)          SET @st = getUTCdate()          INSERT INTO dbo.ResourceCurrent              (                   ResourceTypeId                  ,ResourceSurrogateId                  ,ResourceId                  ,Version                  ,IsDeleted                  ,RequestMethod                  ,RawResource                  ,IsRawResourceMetaSet                  ,SearchParamHash                  ,TransactionId              )            SELECT ResourceTypeId                  ,ResourceSurrogateId                  ,ResourceId                  ,Version                  ,IsDeleted                  ,RequestMethod                  ,RawResource                  ,IsRawResourceMetaSet                  ,SearchParamHash                  ,TransactionId              FROM (SELECT *                      FROM dbo.Resource A WITH (INDEX = 1)                      WHERE ResourceTypeId = @ResourceTypeId                        AND ResourceSurrogateId > @SurrogateId                        AND ResourceSurrogateId <= @CurrentMaxSurrogateId                        AND IsHistory = 0                   ) A              WHERE NOT EXISTS (SELECT * FROM dbo.ResourceCurrent B WHERE B.ResourceTypeId = A.ResourceTypeId AND B.ResourceSurrogateId = A.ResourceSurrogateId) -- surr id from $import insert can point in the past              OPTION (MAXDOP 1)          EXECUTE dbo.LogEvent @Process=@Process,@Status='Run',@Mode=@LastProcessed,@Target='ResourceCurrent',@Action='Insert',@Rows=@@rowcount,@Text=@RowsToProcess,@Start=@st          SET @st = getUTCdate()          INSERT INTO dbo.ResourceHistory              (                   ResourceTypeId                  ,ResourceSurrogateId                  ,ResourceId                  ,Version                  ,IsDeleted                  ,RequestMethod                  ,RawResource                  ,IsRawResourceMetaSet                  ,SearchParamHash                  ,TransactionId              )            SELECT ResourceTypeId                  ,ResourceSurrogateId                  ,ResourceId                  ,Version                  ,IsDeleted                  ,RequestMethod                  ,RawResource                  ,IsRawResourceMetaSet                  ,SearchParamHash                  ,TransactionId              FROM (SELECT TOP (@DummyTop) *                      FROM dbo.Resource A                      WHERE ResourceTypeId = @ResourceTypeId                        AND ResourceSurrogateId > @SurrogateId                        AND ResourceSurrogateId <= @CurrentMaxSurrogateId                        AND IsHistory = 1                   ) A              WHERE NOT EXISTS (SELECT * FROM dbo.ResourceHistory B WHERE B.ResourceTypeId = A.ResourceTypeId AND B.ResourceSurrogateId = A.ResourceSurrogateId) -- history can be inserted by the new version insert in merge              OPTION (MAXDOP 1, OPTIMIZE FOR (@DummyTop = 1))          EXECUTE dbo.LogEvent @Process=@Process,@Status='Run',@Mode=@LastProcessed,@Target='ResourceHistory',@Action='Insert',@Rows=@@rowcount,@Text=@RowsToProcess,@Start=@st          UPDATE dbo.Parameters SET Char = @LastProcessed WHERE Id = @Id          COMMIT TRANSACTION          SET @SurrogateId = @CurrentMaxSurrogateId          SET @ProcessedResources += @RowsToProcess          IF datediff(second, @ReportDate, getUTCdate()) > 60          BEGIN            EXECUTE dbo.LogEvent @Process=@Process,@Status='Run',@Mode=@LastProcessed,@Target='Resource',@Action='Select',@Rows=@ProcessedResources            SET @ReportDate = getUTCdate()            SET @ProcessedResources = 0          END        END        ELSE        BEGIN          COMMIT TRANSACTION          SET @LastProcessed = convert(varchar,@ResourceTypeId)+'.'+convert(varchar,@MaxSurrogateId)          UPDATE dbo.Parameters SET Char = @LastProcessed WHERE Id = @Id        END      END      IF @ProcessedResources > 0        EXECUTE dbo.LogEvent @Process=@Process,@Status='Run',@Mode=@LastProcessed,@Target='Resource',@Action='Select',@Rows=@ProcessedResources      DELETE FROM @Types WHERE ResourceTypeId = @ResourceTypeId      SET @SurrogateId = 0    END    EXECUTE dbo.LogEvent @Process=@Process,@Status='End'  END TRY  BEGIN CATCH    IF @@trancount > 0 ROLLBACK TRANSACTION    IF error_number() = 1750 THROW -- Real error is before 1750, cannot trap in SQL.    EXECUTE dbo.LogEvent @Process=@Process,@Status='Error';    THROW  END CATCH  -- Copy end ----------------------------------------------------------------------------------------------------------  DECLARE @OldRows bigint         ,@CurrentRows bigint         ,@HistoryRows bigint         ,@msg varchar(1000)  BEGIN TRY    BEGIN TRANSACTION -- verification        -- lock input    SET @OldRows = (SELECT TOP 1 1 FROM dbo.Resource (TABLOCKX))    SET @OldRows = (SELECT sum(row_count) FROM sys.dm_db_partition_stats WHERE object_Id = object_id('Resource') AND index_id IN (0,1))    EXECUTE dbo.LogEvent @Process='HistorySeparation.Verification',@Status='Warn',@Target='Resource',@Action='RowsCheck',@Text=@OldRows    SET @CurrentRows = (SELECT sum(row_count) FROM sys.dm_db_partition_stats WHERE object_Id = object_id('ResourceCurrent') AND index_id IN (0,1))    EXECUTE dbo.LogEvent @Process='HistorySeparation.Verification',@Status='Warn',@Target='ResourceCurrent',@Action='RowsCheck',@Text=@CurrentRows    SET @HistoryRows = (SELECT sum(row_count) FROM sys.dm_db_partition_stats WHERE object_Id = object_id('ResourceHistory') AND index_id IN (0,1))    EXECUTE dbo.LogEvent @Process='HistorySeparation.Verification',@Status='Warn',@Target='ResourceHistory',@Action='RowsCheck',@Text=@HistoryRows        IF @CurrentRows + @HistoryRows <> @OldRows    BEGIN      SET @msg = 'OldRows='+convert(varchar,@OldRows)+' <> NewRows='+convert(varchar,@CurrentRows + @HistoryRows)      RAISERROR(@msg,18,127)    END    COMMIT TRANSACTION -- verification    EXECUTE dbo.LogEvent @Process='HistorySeparation.Verification',@Status='Warn',@Text='Completed'    EXECUTE dbo.LogEvent @Process='HistorySeparation.TableViewSwitch',@Status='Warn',@Text='Started'    SET lock_timeout 180000 -- 3 minutes    BEGIN TRANSACTION -- table - view switch    IF EXISTS (SELECT * FROM dbo.Parameters WHERE Id = 'KeepResourceTable' AND Number = 1)      EXECUTE sp_rename 'Resource', 'Resource_Table'    ELSE      DROP TABLE dbo.Resource    --CREATE VIEW dbo.Resource    EXECUTE('CREATE VIEW dbo.ResourceASSELECT ResourceTypeId      ,ResourceSurrogateId      ,ResourceId      ,Version      ,IsHistory      ,IsDeleted      ,RequestMethod      ,RawResource      ,IsRawResourceMetaSet      ,SearchParamHash      ,TransactionId      ,HistoryTransactionId  FROM dbo.ResourceHistoryUNION ALLSELECT ResourceTypeId      ,ResourceSurrogateId      ,ResourceId      ,Version      ,IsHistory      ,IsDeleted      ,RequestMethod      ,RawResource      ,IsRawResourceMetaSet      ,SearchParamHash      ,TransactionId      ,NULL  FROM dbo.ResourceCurrent    ')    EXECUTE dbo.LogEvent @Process='HistorySeparation',@Status='Run',@Target='Resource',@Action='Create'    IF EXISTS (SELECT * FROM sys.objects WHERE name = 'ResourceIns' AND type = 'tr')      DROP TRIGGER dbo.ResourceIns    --CREATE TRIGGER dbo.ResourceIns    EXECUTE('CREATE TRIGGER dbo.ResourceIns ON dbo.Resource INSTEAD OF INSERTASBEGIN  INSERT INTO dbo.ResourceCurrent      (           ResourceTypeId          ,ResourceSurrogateId          ,ResourceId          ,Version          ,IsDeleted          ,RequestMethod          ,RawResource          ,IsRawResourceMetaSet          ,SearchParamHash          ,TransactionId      )    SELECT ResourceTypeId          ,ResourceSurrogateId          ,ResourceId          ,Version          ,IsDeleted          ,RequestMethod          ,RawResource          ,IsRawResourceMetaSet          ,SearchParamHash          ,TransactionId      FROM Inserted      WHERE IsHistory = 0  INSERT INTO dbo.ResourceHistory      (           ResourceTypeId          ,ResourceSurrogateId          ,ResourceId          ,Version          ,IsDeleted          ,RequestMethod          ,RawResource          ,IsRawResourceMetaSet          ,SearchParamHash          ,TransactionId          ,HistoryTransactionId      )    SELECT ResourceTypeId          ,ResourceSurrogateId          ,ResourceId          ,Version          ,IsDeleted          ,RequestMethod          ,RawResource          ,IsRawResourceMetaSet          ,SearchParamHash          ,TransactionId          ,HistoryTransactionId      FROM Inserted      WHERE IsHistory = 1END  ')    EXECUTE dbo.LogEvent @Process='HistorySeparation',@Status='Run',@Target='ResourceIns',@Action='Create'    IF EXISTS (SELECT * FROM sys.objects WHERE name = 'ResourceUpd' AND type = 'tr')      DROP TRIGGER dbo.ResourceUpd    --CREATE TRIGGER dbo.ResourceUpd    EXECUTE('CREATE TRIGGER dbo.ResourceUpd ON dbo.Resource INSTEAD OF UPDATEASBEGIN  IF UPDATE(SearchParamHash) AND NOT UPDATE(IsHistory)  BEGIN    UPDATE B      SET SearchParamHash = A.SearchParamHash -- this is the only update we support      FROM Inserted A           JOIN dbo.ResourceCurrent B ON B.ResourceTypeId = A.ResourceTypeId AND B.ResourceSurrogateId = A.ResourceSurrogateId      WHERE A.IsHistory = 0        RETURN  END  IF NOT UPDATE(IsHistory)    RAISERROR(''Generic updates are not supported via Resource view'',18,127)  DELETE FROM A    FROM dbo.ResourceCurrent A    WHERE EXISTS (SELECT * FROM Inserted B WHERE B.ResourceTypeId = A.ResourceTypeId AND B.ResourceSurrogateId = A.ResourceSurrogateId AND B.IsHistory = 1)  INSERT INTO dbo.ResourceHistory      (           ResourceTypeId          ,ResourceSurrogateId          ,ResourceId          ,Version          ,IsDeleted          ,RequestMethod          ,RawResource          ,IsRawResourceMetaSet          ,SearchParamHash          ,TransactionId          ,HistoryTransactionId      )    SELECT ResourceTypeId          ,ResourceSurrogateId          ,ResourceId          ,Version          ,IsDeleted          ,RequestMethod          ,RawResource          ,IsRawResourceMetaSet          ,SearchParamHash          ,TransactionId          ,HistoryTransactionId      FROM Inserted      WHERE IsHistory = 1END  ')    EXECUTE dbo.LogEvent @Process='HistorySeparation',@Status='Run',@Target='ResourceUpd',@Action='Create'    IF EXISTS (SELECT * FROM sys.objects WHERE name = 'ResourceDel' AND type = 'tr')      DROP TRIGGER dbo.ResourceDel    --CREATE TRIGGER dbo.ResourceDel    EXECUTE('CREATE TRIGGER dbo.ResourceDel ON dbo.Resource INSTEAD OF DELETEASBEGIN  DELETE FROM A    FROM dbo.ResourceCurrent A    WHERE EXISTS (SELECT * FROM Deleted B WHERE B.ResourceTypeId = A.ResourceTypeId AND B.ResourceSurrogateId = A.ResourceSurrogateId AND B.IsHistory = 0)  DELETE FROM A    FROM dbo.ResourceHistory A    WHERE EXISTS (SELECT * FROM Deleted B WHERE B.ResourceTypeId = A.ResourceTypeId AND B.ResourceSurrogateId = A.ResourceSurrogateId AND B.IsHistory = 1)END  ')    EXECUTE dbo.LogEvent @Process='HistorySeparation',@Status='Run',@Target='ResourceDel',@Action='Create'    COMMIT TRANSACTION -- table - view switch    EXECUTE dbo.LogEvent @Process='HistorySeparation.TableViewSwitch',@Status='Warn',@Text='Completed'  END TRY  BEGIN CATCH    IF @@trancount > 0 ROLLBACK TRANSACTION    EXECUTE dbo.LogEvent @Process='HistorySeparation',@Status='Error';    THROW  END CATCHENDGOEXECUTE dbo.LogEvent @Process='HistorySeparation',@Status='End'GO